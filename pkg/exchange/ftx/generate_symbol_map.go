//go:build ignore
// +build ignore

package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
)

type Market struct {
	Name string `json:"name"`
}

type ApiResponse struct {
	Success bool `json:"success"`

	Result []Market `json:"result"`
}

type Exchange struct {
	Name string
	Url  string
}

var FTX_Exchanges = []*Exchange{
	&Exchange{Name: "ftxus", Url: "https://ftx.us/api/markets"},
	&Exchange{Name: "ftx", Url: "https://ftx.com/api/markets"},
}

func main() {
	var data = map[string]string{}

	for i := 0; i < len(FTX_Exchanges); i++ {
		resp, err := http.Get(FTX_Exchanges[i].Url)
		if err != nil {
			log.Fatal(err)
			return
		}
		defer resp.Body.Close()

		r := &ApiResponse{}
		json.NewDecoder(resp.Body).Decode(r)

		for _, m := range r.Result {
			key := strings.ReplaceAll(strings.ToUpper(strings.TrimSpace(m.Name)), "/", "")
			data[key] = m.Name
		}

		f, err := os.Create(FTX_Exchanges[i].Name + "_symbols.go")
		if err != nil {
			log.Fatal(err)
		}

		defer f.Close()

		var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package ftx

var ` + FTX_Exchanges[i].Name + `_symbolMap = map[string]string{
{{- range $k, $v := . }}
	{{ printf "%q" $k }}: {{ printf "%q" $v }},
{{- end }}
}
			`))

		err = packageTemplate.Execute(f, data)
		if err != nil {
			log.Fatal(err)
		}
	}
}
